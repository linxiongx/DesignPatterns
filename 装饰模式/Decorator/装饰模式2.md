<center style="font-size:26px; font-weight:bold">装饰器模式</center>

## 定义

装饰器模式（Decorator Pattern）是一种**结构型设计模式**，它允许在不修改原有类的前提下，通过将对象放入包含行为的特殊封装对象（装饰器）中，来动态地为原对象添加新的功能。

装饰器与被装饰对象实现同一个接口，因此对调用方完全透明。相比继承，装饰器模式更灵活——继承在编译期静态确定行为，而装饰器可以在运行时任意组合叠加。

> **核心思想**：用"包裹"代替"继承"，用"组合"代替"扩展"。

**模式结构：**
- **Component（抽象组件）**：定义对象接口，如 `RequestHandler`
- **ConcreteComponent（具体组件）**：核心业务实现，如 `CoreHandler`
- **Decorator（抽象装饰器）**：持有一个 Component 引用，如 `HandlerDecorator`
- **ConcreteDecorator（具体装饰器）**：在转发调用前后添加额外行为，如 `AuthDecorator`、`LogDecorator`



![image-20260228094932242](C:\Users\6888\AppData\Roaming\Typora\typora-user-images\image-20260228094932242.png)

---

```c++
#include <iostream>
#include <string>
#include <memory>
#include <stdexcept>
#include <chrono>
#include <ctime>

// =====================
// 模拟请求上下文
// =====================
struct Request {
    std::string userId;
    std::string role;      // "guest", "user", "admin"
    std::string action;    // 请求的操作
    bool isLoggedIn;
};

// =====================
// 抽象组件：请求处理器
// =====================
class RequestHandler {
public:
    virtual ~RequestHandler() = default;
    virtual void handle(const Request& req) = 0;
};

// =====================
// 具体组件：核心业务逻辑
// =====================
class CoreHandler : public RequestHandler {
public:
    void handle(const Request& req) override {
        std::cout << "[核心业务] 用户 " << req.userId
                  << " 成功执行操作: " << req.action << "\n";
    }
};

// =====================
// 抽象装饰器
// =====================
class HandlerDecorator : public RequestHandler {
protected:
    std::shared_ptr<RequestHandler> handler_;
public:
    explicit HandlerDecorator(std::shared_ptr<RequestHandler> handler)
        : handler_(std::move(handler)) {}
    
    void handle(const Request& req) override {
        if (handler_) handler_->handle(req);
    }
};

// =====================
// 装饰器1：登录校验
// =====================
class AuthDecorator : public HandlerDecorator {
public:
    using HandlerDecorator::HandlerDecorator;

    void handle(const Request& req) override {
        validateLogin(req);
        std::cout << "[登录校验] ✅ 通过\n";
        handler_->handle(req);
    }

protected:
    void validateLogin(const Request& req) const {
        std::cout << "[登录校验] 检查用户 " << req.userId << " 的登录状态...\n";
        if (!req.isLoggedIn) {
            throw std::runtime_error("❌ 登录校验失败：用户未登录！");
        }
    }
};

// =====================
// 装饰器2：角色权限校验
// =====================
class RoleDecorator : public HandlerDecorator {
    std::string requiredRole_;
public:
    RoleDecorator(std::shared_ptr<RequestHandler> handler, std::string requiredRole)
        : HandlerDecorator(std::move(handler)), requiredRole_(std::move(requiredRole)) {}

    void handle(const Request& req) override {
        validateRole(req);
        std::cout << "[角色校验] ✅ 通过\n";
        handler_->handle(req);
    }

protected:
    void validateRole(const Request& req) const {
        std::cout << "[角色校验] 检查权限: 需要 " << requiredRole_ << "\n";
        if (getRoleLevel(req.role) < getRoleLevel(requiredRole_)) {
            throw std::runtime_error("❌ 角色校验失败：权限不足！");
        }
    }

private:
    int getRoleLevel(const std::string& role) const {
        if (role == "admin") return 3;
        if (role == "user")  return 2;
        return 1;
    }
};

// =====================
// 装饰器3：操作日志
// =====================
class LogDecorator : public HandlerDecorator {
public:
    using HandlerDecorator::HandlerDecorator;

    void handle(const Request& req) override {
        logRequestStart(req);
        handler_->handle(req);
        logRequestEnd();
    }

protected:
    void logRequestStart(const Request& req) const {
        std::cout << "[操作日志] 开始处理请求: " << req.action << " (用户: " << req.userId << ")\n";
    }

    void logRequestEnd() const {
        std::cout << "[操作日志] 请求处理圆满完成。\n";
    }
};

// =====================
// 装饰器4：限流校验
// =====================
class RateLimitDecorator : public HandlerDecorator {
private:
    int maxRequests_;
    int currentCount_ = 0;

public:
    RateLimitDecorator(std::shared_ptr<RequestHandler> handler, int maxRequests)
        : HandlerDecorator(std::move(handler)), maxRequests_(maxRequests) {}

    void handle(const Request& req) override {
        checkRateLimit();
        std::cout << "[限流校验] ✅ 通过\n";
        handler_->handle(req);
    }

protected:
    void checkRateLimit() {
        currentCount_++;
        std::cout << "[限流校验] 当前请求数: " << currentCount_ 
                  << " / " << maxRequests_ << "\n";

        if (currentCount_ > maxRequests_) {
            throw std::runtime_error("❌ 限流校验失败：请求过于频繁，请稍后再试！");
        }
    }

    void resetCount() {
        currentCount_ = 0;
    }
};

// =====================
// 工具函数：执行请求并捕获异常
// =====================
void execute(RequestHandler& handler, const Request& req) {
    std::cout << "\n========== 请求开始 ==========\n";
    try {
        handler.handle(req);
    } catch (const std::exception& e) {
        std::cout << e.what() << "\n";
    }
    std::cout << "========== 请求结束 ==========\n";
}

// =====================
// 客户端：组装不同的校验链
// =====================
int main() {
    // -----------------------------------------------
    // 场景1：普通用户访问普通接口（全部通过）
    // 校验链：日志 → 限流 → 登录 → 角色 → 核心业务
    // -----------------------------------------------
    auto handler1 =
        std::make_shared<LogDecorator>(
            std::make_shared<RateLimitDecorator>(
                std::make_shared<AuthDecorator>(
                    std::make_shared<RoleDecorator>(
                        std::make_shared<CoreHandler>(), "user"
                    )
                ), 5
            )
        );

    Request req1 { "alice", "user", "查看订单", true };
    execute(*handler1, req1);
    
    // -----------------------------------------------
    // 场景2：未登录用户访问（登录校验拦截）
    // -----------------------------------------------
    Request req2 { "anonymous", "guest", "查看订单", false };
    execute(*handler1, req2);
    
    // -----------------------------------------------
    // 场景3：普通用户访问管理员接口（角色校验拦截）
    // -----------------------------------------------
    auto handler2 =
        std::make_shared<LogDecorator>(
            std::make_shared<AuthDecorator>(
                std::make_shared<RoleDecorator>(
                    std::make_shared<CoreHandler>(), "admin"
                )
            )
        );
    
    Request req3 { "bob", "user", "删除用户", true };
    execute(*handler2, req3);
    
    // -----------------------------------------------
    // 场景4：管理员访问管理员接口（全部通过）
    // -----------------------------------------------
    Request req4 { "root", "admin", "删除用户", true };
    execute(*handler2, req4);
    
    return 0;
}
```

---

**输出结果：**
```
========== 请求开始 ==========
[操作日志] 12:00:00 用户=alice 角色=user 操作=查看订单
[限流校验] 当前请求数: 1 / 5
[限流校验] ✅ 通过
[登录校验] 检查用户 alice 的登录状态...
[登录校验] ✅ 通过
[角色校验] 需要角色: user，当前角色: user
[角色校验] ✅ 通过
[核心业务] 用户 alice 成功执行操作: 查看订单
[操作日志] 操作完成，已记录。
========== 请求结束 ==========

========== 请求开始 ==========
[操作日志] 12:00:00 用户=anonymous 角色=guest 操作=查看订单
[限流校验] 当前请求数: 2 / 5
[限流校验] ✅ 通过
[登录校验] 检查用户 anonymous 的登录状态...
❌ 登录校验失败：用户未登录，拒绝访问！
========== 请求结束 ==========

========== 请求开始 ==========
[操作日志] 12:00:00 用户=bob 角色=user 操作=删除用户
[登录校验] 检查用户 bob 的登录状态...
[登录校验] ✅ 通过
[角色校验] 需要角色: admin，当前角色: user
❌ 角色校验失败：权限不足，需要 [admin] 权限！
========== 请求结束 ==========

========== 请求开始 ==========
[操作日志] 12:00:00 用户=root 角色=admin 操作=删除用户
[登录校验] 检查用户 root 的登录状态...
[登录校验] ✅ 通过
[角色校验] 需要角色: admin，当前角色: admin
[角色校验] ✅ 通过
[核心业务] 用户 root 成功执行操作: 删除用户
[操作日志] 操作完成，已记录。
========== 请求结束 ==========
```

---

## 优点

### 符合开闭原则
新增功能只需新写一个装饰器类，无需修改已有的组件或其他装饰器。例如要新增"IP 黑名单校验"，只需新建 `IpBlockDecorator`，原有代码零改动。

### 功能可运行时组合
装饰器的叠加顺序和数量在运行时决定，同一套组件可以按需拼装出完全不同的校验链。例如公开接口只需日志，内部接口叠加登录+角色，高频接口再加上限流，互不干扰。

### 符合单一职责原则
每个装饰器只负责一件事：`AuthDecorator` 只管登录，`RoleDecorator` 只管权限，`LogDecorator` 只管日志。职责边界清晰，独立可测试，修改其中一个不影响其他。

### 比继承更灵活
若用继承叠加功能，N 种功能的组合需要 2^N 个子类；而装饰器只需 N 个类，组合数量不受限制，也不会产生类爆炸问题。

---

## 缺点

### 对象层级变复杂
多层装饰器嵌套后，实际运行的对象链较深，调试时需要逐层追踪。如本例中 `handler1` 实际是四层对象的包裹，出错时堆栈信息不够直观。

### 额外的性能开销
每一层装饰器都是一次虚函数调用和指针间接访问。层数越多，调用链越长。在对延迟极度敏感的场景（如高频交易、实时音视频）中需要评估是否合适。

### 装饰顺序容易出错
装饰器的叠加顺序直接影响行为，顺序写错不会有编译报错，但运行结果可能完全错误。例如将限流放在登录校验之后，未登录请求也会消耗限流计数，这类问题需要靠约定和文档来规避。

### 不适合大量状态共享的场景
各装饰器之间通过 `Request` 对象传递数据，如果多个装饰器需要读写共享状态（如缓存、会话），需要额外设计上下文传递机制，否则会导致装饰器之间出现隐式耦合。