# 桥接模式 (Bridge Pattern)

## 什么是桥接模式？

桥接模式是一种结构型设计模式，它的核心思想是**将抽象部分与它的实现部分分离，使它们都可以独立地变化**。

通常情况下，我们使用继承来扩展类的功能。但是，如果一个类在多个维度上都有变化（例如形状和颜色），使用继承会导致类的数量爆炸式增长（例如：红圆形、蓝圆形、红正方形、蓝正方形...）。

桥接模式通过**组合**（Composition）关系代替**继承**（Inheritance）关系，将这两个维度分离出来，让它们各自发展，然后通过一个“桥”将它们连接起来。

## 本例解析

在我们的 `main.cpp` 例子中，很好的体现了桥接模式：

1.  **抽象部分 (Abstraction) - `Shape` 类**
    *   `Shape` 是一个抽象类，代表“形状”这个维度。
    *   它**持有**一个指向实现接口的指针：`std::shared_ptr<Color> color`。
    *   它的 `draw()` 方法虽然定义了画图的动作，但具体的颜色填充是委托给 `color` 对象去做的。

2.  **实现部分 (Implementor) - `Color` 接口**
    *   `Color` 是一个接口（抽象基类），代表“颜色”这个维度。
    *   它定义了 `fill()` 方法，由具体的颜色类去实现。

3.  **具体的桥接**
    *   当我们创建一个形状时，我们需要传入一个颜色对象：
        ```cpp
        // 创建实现（颜色）
        auto red = std::make_shared<Red>();
        // 创建抽象并桥接（红色圆形）
        std::shared_ptr<Shape> redCircle = std::make_shared<Circle>(red);
        ```
    *   这里 `Circle` (RefinedAbstraction) 通过父类 `Shape` 中的 `color` 指针，与 `Red` (ConcreteImplementor) 建立了联系。

## 适用场景

1.  **多维度变化**：如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系。
2.  **避免类爆炸**：一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。
3.  **独立扩展**：对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

## 优缺点

### 优点
*   **分离抽象接口及其实现部分**：也就是解耦。
*   **提高了系统的可扩充性**：可以独立地对抽象化角色和具体化角色进行扩展。
*   **符合开闭原则**：增加新的形状或新的颜色，不需要修改现有的代码。
*   **符合合成复用原则**：优先使用对象组合，而不是类继承。

### 缺点
*   **增加了系统的理解和设计难度**：由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。
*   **需要正确识别出系统中两个独立变化的维度**：如果识别错误，可能导致设计变得复杂且不合理。
